#!/usr/bin/env node

require('dotenv').config();
const { Command } = require('commander');
const path = require('path');
const crypto = require('crypto');

// ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™
const { log, displayTitle } = require('./lib/logger');
const { validateOptions, Timer } = require('./lib/cli-helpers');

// Ê©üËÉΩÂà•„É¢„Ç∏„É•„Éº„É´
const { getAwsConfiguration } = require('./modules/aws-config-module');
const { setupCustomDomain } = require('./modules/custom-domain-module');
const { updateLocalEnv } = require('./modules/env-local-module');
const { updateVercelEnvironmentVariables, getExistingAuthSecret } = require('./modules/vercel-env-module');
const { triggerDeployment } = require('./lib/vercel-helpers');

// „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÅÆË®≠ÂÆö
const program = new Command();

program
    .name('setup-environment')
    .description('Complete environment setup: AWS + Custom Domain + .env.local + Vercel')
    .version('1.0.0')
    .requiredOption('-p, --profile <profile>', 'AWS SSO profile name')
    .option('-e, --environment <env>', 'Environment to setup (dev/prod)')
    .option('-r, --region <region>', 'AWS region (defaults to profile default)')
    .option('--vercel-env <env>', 'Vercel environment (preview/production)', 'auto')
    .option('--env-file <file>', 'Environment file path', '.env.local')
    .option('--skip-custom-domain', 'Skip custom domain setup')
    .option('--skip-env-local', 'Skip .env.local generation')
    .option('--skip-vercel', 'Skip Vercel environment variables')
    .option('--skip-deploy', 'Skip Vercel deployment (even with --force-update)')
    .option('--force-update', 'Force update existing configurations')
    .option('--dry-run', 'Show what would be done without making changes')
    .option('--require-approval <type>', 'Require approval for changes', 'always')
    .option('--debug', 'Enable debug output');

/**
 * AUTH_SECRET„ÇíÂèñÂæó„Åæ„Åü„ÅØÊñ∞Ë¶è‰ΩúÊàê
 * @param {string} environment - Áí∞Â¢É (dev/prod)
 * @param {string} envFilePath - .env.local„Éï„Ç°„Ç§„É´„Éë„Çπ
 * @param {Object} vercelConfig - VercelË®≠ÂÆö {apiToken, projectId}
 * @returns {string} AUTH_SECRET
 */
async function getOrCreateAuthSecret(environment, envFilePath, vercelConfig) {
    
    // 1. .env.local„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°åÔºàdevÁí∞Â¢É„ÅÆ„ÅøÔºâ
    if (environment === 'dev') {
        try {
            const fs = require('fs').promises;
            const envContent = await fs.readFile(envFilePath, 'utf8');
            const authSecretMatch = envContent.match(/^AUTH_SECRET=(.+)$/m);
            if (authSecretMatch) {
                log.debug('Found existing AUTH_SECRET in .env.local', { debug: true });
                return authSecretMatch[1].replace(/['"]/g, ''); // „ÇØ„Ç©„Éº„ÉàÈô§Âéª
            }
        } catch (error) {
            log.debug('No existing .env.local file found', { debug: true });
        }
    }

    // 2. Vercel„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°å
    if (vercelConfig.apiToken && vercelConfig.projectId) {
        try {
            const existingSecret = await getExistingAuthSecret(
                vercelConfig.apiToken, 
                vercelConfig.projectId
            );
            if (existingSecret) {
                log.debug('Found existing AUTH_SECRET in Vercel', { debug: true });
                return existingSecret;
            }
        } catch (error) {
            log.debug(`Failed to get AUTH_SECRET from Vercel: ${error.message}`, { debug: true });
        }
    }

    // 3. Êñ∞Ë¶èÁîüÊàê
    const newSecret = crypto.randomBytes(32).toString('base64');
    log.info('Generated new AUTH_SECRET');
    return newSecret;
}

/**
 * Áí∞Â¢ÉÂ§âÊï∞„ÅÆÊ§úË®º
 */
function validateEnvironmentVariables(options) {
    const required = [];

    // Vercel„ÅåÊúâÂäπ„ÅßDeploy Hook„ÅåÊúâÂäπ„Å™Â†¥Âêà
    if (!options.skipVercel) {
        const deployHookProd = process.env.VERCEL_DEPLOY_HOOK_PROD;
        const deployHookDev = process.env.VERCEL_DEPLOY_HOOK_DEV;
        
        if (!deployHookDev) {
            required.push('VERCEL_DEPLOY_HOOK_DEV');
        }
        if (!deployHookProd) {
            required.push('VERCEL_DEPLOY_HOOK_PROD');
        }
    }

    // Custom Domain„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆÂøÖÈ†àÁí∞Â¢ÉÂ§âÊï∞
    if (!options.skipCustomDomain) {
        if (!process.env.CLOUDFLARE_API_TOKEN) {
            required.push('CLOUDFLARE_API_TOKEN');
        }
        if (!process.env.CLOUDFLARE_ZONE_ID) {
            required.push('CLOUDFLARE_ZONE_ID');
        }
    }

    if (required.length > 0) {
        log.error(`Missing required environment variables: ${required.join(', ')}`);
        log.warning('Please set these variables in your .env file or environment');
        process.exit(1);
    }
}

/**
 * VercelÁí∞Â¢É„ÅÆËá™ÂãïÊ±∫ÂÆö
 */
function determineVercelEnvironment(environment, vercelEnvOption) {
    if (vercelEnvOption !== 'auto') {
        return vercelEnvOption;
    }

    const mapping = {
        'dev': 'preview',
        'prod': 'production'
    };

    return mapping[environment] || 'preview';
}

/**
 * Ë®≠ÂÆö„Çµ„Éû„É™„Éº„ÅÆË°®Á§∫
 */
function displayConfigurationSummary(options, vercelEnv) {
    log.info('üìã Configuration Summary:');
    console.log(`   AWS Profile: ${options.profile}`);
    console.log(`   AWS Region: ${options.region || 'profile default'}`);
    console.log(`   Environment: ${options.environment}`);
    console.log(`   Vercel Environment: ${vercelEnv}`);
    console.log(`   Environment File: ${options.envFile}`);
    console.log('');
    console.log('üìù Operations to perform:');
    console.log(`   ‚úÖ AWS Configuration Retrieval`);
    console.log(`   ${options.skipCustomDomain ? '‚è≠Ô∏è' : '‚úÖ'} Custom Domain Setup`);
    console.log(`   ${options.environment !== 'dev' ? '‚è≠Ô∏è' : options.skipEnvLocal ? '‚è≠Ô∏è' : '‚úÖ'} .env.local Generation`);
    console.log(`   ${options.skipVercel ? '‚è≠Ô∏è' : '‚úÖ'} Vercel Environment Variables`);
    console.log(`   ${options.skipDeploy || !options.forceUpdate ? '‚è≠Ô∏è' : '‚úÖ'} Vercel Deployment`);
    
    if (options.dryRun) {
        console.log('');
        log.warning('üß™ DRY-RUN MODE: No changes will be made');
    }
}

/**
 * „É°„Ç§„É≥Âá¶ÁêÜ
 */
async function main() {
    const timer = new Timer();

    try {
        // „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Çí„Éë„Éº„Çπ
        program.parse();
        const options = program.opts();

        // ÂºïÊï∞Ê§úË®º
        validateOptions(options, ['profile']);

        // Áí∞Â¢ÉÂ§âÊï∞Ê§úË®º
        validateEnvironmentVariables(options);

        // VercelÁí∞Â¢É„ÅÆÊ±∫ÂÆö
        const vercelEnv = determineVercelEnvironment(options.environment, options.vercelEnv);

        // „Çø„Ç§„Éà„É´Ë°®Á§∫
        displayTitle('Sankey Environment Setup - Complete Automation');

        // Ë®≠ÂÆö„Çµ„Éû„É™„ÉºË°®Á§∫
        displayConfigurationSummary(options, vercelEnv);

        // Step 1: AWSË®≠ÂÆöÂèñÂæó
        log.info('üîç Step 1: Retrieving AWS Configuration...');
        const awsConfig = await getAwsConfiguration({
            profile: options.profile,
            environment: options.environment,
            region: options.region,
            debug: options.debug,
            requireApproval: options.requireApproval
        });

        if (!awsConfig) {
            throw new Error('Failed to retrieve AWS configuration');
        }

        log.success('‚úÖ AWS configuration retrieved successfully');
        log.debug(`AWS Config: ${JSON.stringify(awsConfig, null, 2)}`, options);

        // AUTH_SECRETÂèñÂæó
        const envFilePath = path.resolve(process.cwd(), options.envFile);
        const authSecret = await getOrCreateAuthSecret(
            options.environment,
            envFilePath,
            { 
                apiToken: process.env.VERCEL_TOKEN, 
                projectId: process.env.VERCEL_PROJECT_ID 
            }
        );

        // Step 2: Custom DomainË®≠ÂÆö
        if (!options.skipCustomDomain) {
            log.info('üö™ Step 2: Setting up Custom Domain...');
            await setupCustomDomain({
                awsConfig,
                environment: options.environment,
                profile: options.profile,
                region: options.region,
                dryRun: options.dryRun,
                forceRenew: options.forceUpdate,
                debug: options.debug
            });
            log.success('‚úÖ Custom domain setup completed');
        } else {
            log.info('‚è≠Ô∏è Step 2: Skipping Custom Domain setup');
        }

        // Step 3: .env.localÁîüÊàêÔºàdevÁí∞Â¢É„ÅÆ„ÅøÔºâ
        if (options.environment === 'dev' && !options.skipEnvLocal) {
            log.info('üìù Step 3: Generating .env.local file...');
            await updateLocalEnv({
                awsConfig,
                authSecret,
                envFilePath,
                debug: options.debug
            });
            log.success('‚úÖ .env.local file updated');
        } else {
            log.info('‚è≠Ô∏è Step 3: Skipping .env.local (not dev environment)');
        }

        // Step 4: VercelÁí∞Â¢ÉÂ§âÊï∞Ë®≠ÂÆö
        let vercelUpdated = false;
        if (!options.skipVercel) {
            log.info('üîß Step 4: Setting up Vercel Environment Variables...');
            const vercelResults = await updateVercelEnvironmentVariables({
                awsConfig,
                environment: options.environment,
                vercelEnvironment: vercelEnv,
                apiToken: process.env.VERCEL_TOKEN,
                projectId: process.env.VERCEL_PROJECT_ID,
                authSecret,
                forceUpdate: options.forceUpdate,
                dryRun: options.dryRun,
                debug: options.debug
            });
            
            // Áí∞Â¢ÉÂ§âÊï∞„ÅåÊõ¥Êñ∞„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„Éá„Éó„É≠„Ç§„ÅåÂøÖË¶Å
            vercelUpdated = vercelResults.results && 
                (vercelResults.results.created.length > 0 || vercelResults.results.updated.length > 0);
            
            log.success('‚úÖ Vercel environment variables updated');
        } else {
            log.info('‚è≠Ô∏è Step 4: Skipping Vercel environment variables');
        }

        // Step 5: Vercel „Éá„Éó„É≠„Ç§Ôºà--force-updateÊôÇ„ÅÆ„ÅøÔºâ
        if (!options.skipVercel && !options.skipDeploy && options.forceUpdate && vercelUpdated && !options.dryRun) {
            log.info('üöÄ Step 5: Triggering Vercel Deployment...');
            try {
                const deployResult = await triggerDeployment(
                    vercelEnv,
                    {
                        debug: options.debug
                    }
                );
                log.success('‚úÖ Vercel deployment triggered successfully');
                if (deployResult.url) {
                    log.info(`üîó Deployment URL: ${deployResult.url}`);
                }
            } catch (error) {
                log.warning(`‚ö†Ô∏è Deployment failed: ${error.message}`);
                log.info('You may need to deploy manually from Vercel dashboard or check Vercel CLI installation');
            }
        } else if (options.forceUpdate && vercelUpdated) {
            if (options.skipDeploy) {
                log.info('‚è≠Ô∏è Step 5: Skipping Vercel deployment (--skip-deploy)');
            } else if (options.dryRun) {
                log.info('‚è≠Ô∏è Step 5: Skipping Vercel deployment (dry-run mode)');
            } else {
                log.info('‚è≠Ô∏è Step 5: Skipping Vercel deployment (no --force-update)');
            }
            log.warning('üí° Environment variables were updated. Consider deploying manually.');
        } else {
            log.info('‚è≠Ô∏è Step 5: No deployment needed (no environment variable changes)');
        }

        // ÂÆå‰∫ÜÂ†±Âëä
        console.log('');
        log.complete('üéâ Environment setup completed successfully!');
        
        console.log('\nüìã Summary:');
        console.log(`   Environment: ${options.environment.toUpperCase()}`);
        console.log(`   AWS Profile: ${options.profile}`);
        console.log(`   Vercel Environment: ${vercelEnv}`);
        
        if (options.environment === 'dev' && !options.skipEnvLocal) {
            console.log(`   Environment File: ${options.envFile}`);
        }

        console.log('\nüöÄ Next Steps:');
        if (options.environment === 'dev' && !options.skipEnvLocal) {
            console.log('   1. Restart your Next.js application: npm run dev');
        }
        console.log('   2. Test your API endpoints');
        console.log('   3. Verify authentication flow');
        if (!vercelUpdated || options.skipDeploy) {
            console.log('   4. Deploy your frontend: git push');
        }

        timer.log('üéØ Total setup time');

    } catch (error) {
        log.error(`Setup failed: ${error.message}`);

        // Ë©≥Á¥∞„Å™„Ç®„É©„ÉºÊÉÖÂ†±Ôºà„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊôÇÔºâ
        if (program.opts().debug) {
            console.error('\nüîç Debug Information:');
            console.error(error.stack);
        }

        // „Ç®„É©„ÉºÂà•„ÅÆ„Éò„É´„Éó„É°„ÉÉ„Çª„Éº„Ç∏
        if (error.message.includes('profile')) {
            log.warning('üí° Make sure you have run: aws sso login --profile ' + (program.opts().profile || '<profile>'));
        }

        if (error.message.includes('VERCEL_TOKEN')) {
            log.warning('üí° Get your Vercel token from: https://vercel.com/account/tokens');
        }

        if (error.message.includes('CLOUDFLARE_API_TOKEN')) {
            log.warning('üí° Get your Cloudflare token from: https://dash.cloudflare.com/profile/api-tokens');
        }

        process.exit(1);
    }
}

// „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
process.on('uncaughtException', (error) => {
    log.error(`Uncaught exception: ${error.message}`);
    if (program.opts()?.debug) {
        console.error(error.stack);
    }
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    log.error(`Unhandled rejection: ${reason}`);
    process.exit(1);
});

// ÂÆüË°å
if (require.main === module) {
    main();
}